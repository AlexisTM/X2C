// Copyright (c) 2017, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
// All rights reserved.
//
// This file is licensed according to the BSD 3-clause license as follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the "Linz Center of Mechatronics GmbH" and "LCM" nor
//       the names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL "Linz Center of Mechatronics GmbH" BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file is part of X2C. http://www.mechatronic-simulation.org/
// $LastChangedRevision: 1111 $
// $LastChangedDate:: 2017-02-28 14:18:07 +0100#$
//
// Creates C-code computational function of IO blocks in General library.

function [] = createCFunctionIO()
funcprot(0);

// import necessary java classes
jimport at.lcm.x2c.utils.LibraryUtils;

// get file separator
fs = filesep(); 

// get some block information
libName = "General"
xmlPath = jinvoke(LibraryUtils, "getXmlDirectory", libName);
xmlDir = jinvoke(xmlPath, "toString");
blockInfo.scilabDir = strsubst(xmlDir, ["XML" + fs], ["Scilab" + fs]);

// get datatype names of IO-blocks
ImplNames = getIODataTypes();


//------------------------------------------------------------------------------
// Create C-functions for inport
//------------------------------------------------------------------------------
curXml = [xmlPath + "Inport.xml"];
blockInfo.blockName = "Inport";
blockInfo.xcosName = "x2c_Inport";
try 
    // go through all available implementations
    for curImpl=ImplNames
        
        // open/create file
        fileName = blockInfo.scilabDir + blockInfo.xcosName + "_" + curImpl + "_C.c";
        fileID = mopen(fileName, "wt");
        
        // print header
        time = datevec(datenum());
        mfprintf(fileID, "// This file was generated by %s on %02d-%02d-%04d %02d:%02d\n\n", "createCFunctionAux.sci", time(3), time(2), time(1), time(4), time(5));
        mfprintf(fileID, "// Computational function for X2C block %s\n\n", blockInfo.blockName);
        // TODO: expand file header (e.g. with license)

        mfprintf(fileID, "#define SCILAB_SIM_FILE /* mark this file as Scilab simulation file */\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* include Scicos / Xcos headers */\n");
        mfprintf(fileID, "#include <scicos.h>\n");
        mfprintf(fileID, "#include <scicos_block4.h>\n");
        mfprintf(fileID, "#include <Simulation_PortConversion.h>\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* private prototypes */\n");
        mfprintf(fileID, "void %s_%s_C(scicos_block* block, scicos_flag flag);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__OutputUpdate(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__StateUpdate(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__Initialization(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__Ending(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "void %s_%s_C(scicos_block* block, scicos_flag flag) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    /*\n");
        mfprintf(fileID, "     * This function will be called by Xcos\n");
        mfprintf(fileID, "     */\n");
        mfprintf(fileID, "    switch (flag) {\n");
        mfprintf(fileID, "        case DerivativeState:  /* 0 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case OutputUpdate:     /* 1 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__OutputUpdate(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case StateUpdate:      /* 2 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__StateUpdate(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case OutputEventTiming: /* 3 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case Initialization:   /* 4 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__Initialization(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case Ending:           /* 5 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__Ending(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ReInitialization: /* 6 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ContinousPropertiesUpdate: /* 7 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ZeroCrossing:     /* 9 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "           break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        default:     /* Jacobian (v5.5.0) or Residute (v5.4.1) or something else */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "           break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "    }\n");
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        //----------------------------------------------------------------------
        // Initialization
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__Initialization(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");

        //----------------------------------------------------------------------
        // Ending
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__Ending(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        //----------------------------------------------------------------------
        // State Update f
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__StateUpdate_f(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        

        //----------------------------------------------------------------------
        // State Update
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__StateUpdate(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    if (GetNevIn(block) > 0) {\n");
        mfprintf(fileID, "        /*\n");
        mfprintf(fileID, "        * GetNevIn(block) returns -1 in in case this function was called due to an internal zero-crossing.\n");
        mfprintf(fileID, "        * GetNevIn(block)  ... activation index\n");
        mfprintf(fileID, "        */\n");
        mfprintf(fileID, "        %s_%s_C__StateUpdate_f(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    }\n");
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        

        //----------------------------------------------------------------------
        // Output Update
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__OutputUpdate(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    double *outport_Out;\n");
        mfprintf(fileID, "    double *inport_In_p;\n");
        mfprintf(fileID, "    \n");
        mfprintf(fileID, "    outport_Out = GetOutPortPtrs(block, 1);\n");
        mfprintf(fileID, "    inport_In_p = GetInPortPtrs(block, 1);\n");
        curFormat = dataTypeToQFormat(curImpl);
        mfprintf(fileID, "    *outport_Out = convert_%s_to_double(convert_double_to_%s(*inport_In_p));\n", curFormat, curFormat);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        // close file
        mclose(fileID);
        mprintf("Computational function %s successfully written.\n", fileName);
    end
    
catch
    // some error creating the file occured
    //mclose(fileID); // try to close the file
    disp("Error creating C-code files for block " + blockInfo.blockName + ": " + lasterror());
end

//------------------------------------------------------------------------------
// Create C-code computational functions for outport
//------------------------------------------------------------------------------
curXml = [xmlPath + "Outport.xml"];
blockInfo.blockName = "Outport";
blockInfo.xcosName = "x2c_Outport";
try 
    // go through all available implementations
    for curImpl=ImplNames

        // open/create file
        fileName = blockInfo.scilabDir + blockInfo.xcosName + "_" + curImpl + "_C.c";
        fileID = mopen(fileName, "wt");
        
        // print header
        time = datevec(datenum());
        mfprintf(fileID, "// This file was generated by %s on %02d-%02d-%04d %02d:%02d\n\n", "createCFunctionAux.sci", time(3), time(2), time(1), time(4), time(5));
        mfprintf(fileID, "// Computational function for X2C block %s\n\n", blockInfo.blockName);
        // TODO: expand file header (e.g. with license)

        mfprintf(fileID, "#define SCILAB_SIM_FILE\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* include Scicos / Xcos headers */\n");
        mfprintf(fileID, "#include <scicos.h>\n");
        mfprintf(fileID, "#include <scicos_block4.h>\n");
        mfprintf(fileID, "#include <Simulation_PortConversion.h>\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* private prototypes */\n");
        mfprintf(fileID, "void %s_%s_C(scicos_block* block, scicos_flag flag);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__OutputUpdate(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__StateUpdate(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__Initialization(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__Ending(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "void %s_%s_C(scicos_block* block, scicos_flag flag) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    /*\n");
        mfprintf(fileID, "     * This function will be called by Xcos\n");
        mfprintf(fileID, "     */\n");
        mfprintf(fileID, "    switch (flag) {\n");
        mfprintf(fileID, "        case DerivativeState:  /* 0 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case OutputUpdate:     /* 1 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__OutputUpdate(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case StateUpdate:      /* 2 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__StateUpdate(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case OutputEventTiming: /* 3 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case Initialization:   /* 4 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__Initialization(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case Ending:           /* 5 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__Ending(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ReInitialization: /* 6 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ContinousPropertiesUpdate: /* 7 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ZeroCrossing:     /* 9 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "           break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        default:     /* Jacobian (v5.5.0) or Residute (v5.4.1) or something else */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "           break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "    }\n");
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        //----------------------------------------------------------------------
        // Initialization
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__Initialization(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");

        //----------------------------------------------------------------------
        // Ending
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__Ending(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        //----------------------------------------------------------------------
        // State Update f
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__StateUpdate_f(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        

        //----------------------------------------------------------------------
        // State Update
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__StateUpdate(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    if (GetNevIn(block) > 0) {\n");
        mfprintf(fileID, "        /*\n");
        mfprintf(fileID, "        * GetNevIn(block) returns -1 in in case this function was called due to an internal zero-crossing.\n");
        mfprintf(fileID, "        * GetNevIn(block)  ... activation index\n");
        mfprintf(fileID, "        */\n");
        mfprintf(fileID, "        %s_%s_C__StateUpdate_f(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    }\n");
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        

        //----------------------------------------------------------------------
        // Output Update
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__OutputUpdate(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    double *outport_Out;\n");
        mfprintf(fileID, "    double *inport_In_p;\n");
        mfprintf(fileID, "    \n");
        mfprintf(fileID, "    outport_Out = GetOutPortPtrs(block, 1);\n");
        mfprintf(fileID, "    inport_In_p = GetInPortPtrs(block, 1);\n");
        curFormat = dataTypeToQFormat(curImpl);
        mfprintf(fileID, "    *outport_Out = convert_%s_to_double(convert_double_to_%s(*inport_In_p));\n", curFormat, curFormat);
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        // close file
        mclose(fileID);
        mprintf("Computational function %s successfully written.\n", fileName);
    end
    
catch
    // some error creating the file occured
    //mclose(fileID); // try to close the file
    disp("Error creating C-code files for block " + blockInfo.blockName + ": " + lasterror());
end

endfunction


// Converts enum data type string to corresponding Q-format string
// Parameters:
// dataType - enum data type
// QFormat - corresponding Q-format string
function [QFormat] = dataTypeToQFormat(dataType)
    
select dataType
    case "int8" then
        QFormat = "Q7";
    case "uint8" then
        QFormat = "Q7";
    case "int16" then
        QFormat = "Q15";
    case "uint16" then
        QFormat = "Q15";
    case "int32" then
        QFormat = "Q31";
    case "uint32" then
        QFormat = "Q31";
    case "int64" then
        QFormat = "Q63";
    case "uint64" then
        QFormat = "Q63";
    case "float32" then
        QFormat = "float32";
    case "float64" then
        QFormat = "float64";
    else
        QFormat = dataType;
end
    
endfunction

