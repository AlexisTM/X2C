// Copyright (c) 2017, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
// All rights reserved.
//
// This file is licensed according to the BSD 3-clause license as follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the "Linz Center of Mechatronics GmbH" and "LCM" nor
//       the names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL "Linz Center of Mechatronics GmbH" BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file is part of X2C. http://www.mechatronic-simulation.org/
// $LastChangedRevision: 1111 $
// $LastChangedDate:: 2017-02-28 14:18:07 +0100#$
//
// Creates C-code computational function for simulation in Xcos.
// Parameters:
// libName - Library name
// block - Java X2C block object
// varargin - (optional) project root directory for external blocks

function [] = createCFunction(libName, block, varargin)
funcprot(0);

// import necessary java classes
jimport at.lcm.x2c.core.structure.ControlBlock;
jimport at.lcm.x2c.utils.LibraryUtils;

//------------------------------------------------------------------------------
// Get relevant block information
//------------------------------------------------------------------------------
if length(varargin) == 0 then
    // internal library
    blockInfo = getBlockInfo(libName, block);
else
    // external library
    blockInfo = getBlockInfo(libName, block, varargin(1));
end

//------------------------------------------------------------------------------
// Create C-code computational functions
//------------------------------------------------------------------------------
try 
    // go through all available implementations
    for curImpl=blockInfo.Implementations

        // fetch implementation details
        jinvoke(block, "setUsedImplementation", curImpl);
        parameterNames = jinvoke(block, "getUsedImplementationParameterNames");
        inportNames = jinvoke(block, "getUsedImplementationInportNames");
        outportNames = jinvoke(block, "getUsedImplementationOutportNames");

        // open/create file
        fileName = blockInfo.scilabDir + blockInfo.xcosName + "_" + curImpl + "_C.c";
        fileID = mopen(fileName, "wt");
        
        // print header
        time = datevec(datenum());
        mfprintf(fileID, "// This file was generated by %s on %02d-%02d-%04d %02d:%02d\n\n", "createCFunction.sci", time(3), time(2), time(1), time(4), time(5));
        mfprintf(fileID, "// Computational function for X2C block %s\n\n", blockInfo.blockName);
        // TODO: expand file header (e.g. with license)


        mfprintf(fileID, "#define SCILAB_SIM_FILE /* mark this file as Scilab simulation file */\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* include Scicos / Xcos headers */\n");
        mfprintf(fileID, "#include <scicos.h>\n");
        mfprintf(fileID, "#include <scicos_block4.h>\n");
        mfprintf(fileID, "#include <scicos_malloc.h>\n");
        mfprintf(fileID, "#include <scicos_free.h>\n");
        mfprintf(fileID, "#include <Simulation_PortConversion.h>\n");
        mfprintf(fileID, "//#define DEBUG // uncomment to enable debugging\n");
        mfprintf(fileID, "#ifdef DEBUG\n");
        mfprintf(fileID, "    #include <stdio.h>\n");
        mfprintf(fileID, "#endif\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* include block implementation */\n");
        mfprintf(fileID, "#include <%s_%s.h>\n", blockInfo.blockName, curImpl);
        mfprintf(fileID, "#include <%s_%s.c>\n", blockInfo.blockName, curImpl);
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* */\n");
        mfprintf(fileID, "#define BLOCK_ERROR_INPUT_OUT_OF_DOMAIN (-1)\n");
        mfprintf(fileID, "#define BLOCK_ERROR_SINGULARITY (-2)\n");
        mfprintf(fileID, "#define BLOCK_ERROR_INTERNAL (-3)\n");
        mfprintf(fileID, "#define BLOCK_ERROR_CANNOT_ALLOCATE_MEMORY (-16)\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "/* */\n");
        mfprintf(fileID, "void %s_%s_C(scicos_block* block, scicos_flag flag);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__OutputUpdate(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__StateUpdate(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__Initialization(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "static void %s_%s_C__Ending(scicos_block* block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "\n");
        mfprintf(fileID, "\n");
        mfprintf(fileID, "void %s_%s_C(scicos_block* block, scicos_flag flag) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    /*\n");
        mfprintf(fileID, "     * This function will be called by Xcos\n");
        mfprintf(fileID, "     */\n");
        mfprintf(fileID, "    switch (flag) {\n");
        mfprintf(fileID, "        case DerivativeState:  /* 0 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case OutputUpdate:     /* 1 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__OutputUpdate(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case StateUpdate:      /* 2 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__StateUpdate(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case OutputEventTiming: /* 3 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case Initialization:   /* 4 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__Initialization(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case Ending:           /* 5 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            %s_%s_C__Ending(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ReInitialization: /* 6 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ContinousPropertiesUpdate: /* 7 */\n");

        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "            break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        case ZeroCrossing:     /* 9 */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "           break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "        default:     /* Jacobian (v5.5.0) or Residute (v5.4.1) or something else */\n");
        mfprintf(fileID, "        {\n");
        mfprintf(fileID, "           break;\n");
        mfprintf(fileID, "        }\n");
        mfprintf(fileID, "    }\n");
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");

        //----------------------------------------------------------------------
        // set parameter
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__set_parameter(scicos_block* block, %s_%s *blockParam) {\n", blockInfo.xcosName, curImpl, convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"));
        mfprintf(fileID, "    int *paramI;\n");
        mfprintf(fileID, "    double *paramR;\n");
        mfprintf(fileID, "    %s_%s *pT%s_%s;\n", convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"), blockInfo.blockName, curImpl);
        mfprintf(fileID, "    \n");
        mfprintf(fileID, "    /* *** */\n");
        mfprintf(fileID, "    paramI = GetIparPtrs(block);  /* integer parameters  */\n");
        mfprintf(fileID, "    paramR = GetRparPtrs(block);  /* real parameters     */\n");
        mfprintf(fileID, "    pT%s_%s = GetWorkPtrs(block);\n", blockInfo.blockName, curImpl);
        indexI = 0;
        indexR = 0;
        for curParam=parameterNames
            // fetch parameter details
            controllerParameter = jinvoke(block, "getUsedImplementationParameter", curParam);
            controllerDataType = jinvoke(controllerParameter, "getDataType");
            parameter.Type = jinvoke(controllerDataType, "getName");
            parameter.isInteger = jinvoke(controllerDataType, "isInteger");
            parameter.isArray = jinvoke(controllerParameter, "isArray");
            parameter.isFlashArray = jinvoke(controllerParameter, "isFlashArray");
            parameter.isSaveable = jinvoke(controllerParameter, "isSaveable");
          
            if parameter.isArray then
                // do nothing here, parameter arrays are handled differently
            elseif (parameter.isSaveable & ~parameter.isFlashArray)
                if parameter.isInteger then
                    mfprintf(fileID, "    blockParam->%s = (%s)paramI[%i];\n", curParam, parameter.Type, indexI);
                    indexI = indexI + 1;
                else
                    mfprintf(fileID, "    blockParam->%s = (%s)paramR[%i];\n", curParam, parameter.Type, indexR);
                    indexR = indexR + 1;
                end
            end
        end
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");

        //----------------------------------------------------------------------
        // Initialization
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__Initialization(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
       
        mfprintf(fileID, "    %s_%s *pT%s_%s;\n", convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"), blockInfo.blockName, curImpl);
        
        mfprintf(fileID, "\n    /* Declaration of inports */\n");
        for curInport=inportNames
            curInportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getInport", curInport), "getDataType"), "getName");
            mfprintf(fileID, "    double *inport_%s_p;\n", curInport);
            mfprintf(fileID, "    %s inport_%s;\n", curInportType, curInport);
        end
        
        mfprintf(fileID, "\n    /* Declaration of outports */\n");
        for curOutport=outportNames
            mfprintf(fileID, "    double *outport_%s;\n", curOutport);
        end
        
        mfprintf(fileID, "\n    /* *** */\n");
        mfprintf(fileID, "    pT%s_%s = scicos_malloc(sizeof(%s_%s)",blockInfo.blockName, curImpl, convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"));
        index = 1;
        for curParam=parameterNames
            // fetch parameter details
            controllerParameter = jinvoke(block, "getUsedImplementationParameter", curParam);
            parameter.isArray = jinvoke(controllerParameter, "isArray");
            parameter.isFlashArray = jinvoke(controllerParameter, "isFlashArray");
            if parameter.isArray & ~parameter.isFlashArray then
                curParamType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getParameter", curParam), "getDataType"), "getName");
                curArraySize = jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getParameter", curParam), "getRamArraySize");
                mfprintf(fileID, " + sizeof(%s)*%i", curParamType, curArraySize);
            end
            if parameter.isFlashArray then
                curParamType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getParameter", curParam), "getDataType"), "getName");
                mfprintf(fileID, " + sizeof(%s)*GetOparSize(block, %i, 2)", curParamType, index);
            end
            index = index + 1;
        end
        mfprintf(fileID, ");\n");
        mfprintf(fileID, "    GetWorkPtrs(block) = pT%s_%s;\n", blockInfo.blockName, curImpl);
        
        index = 1;
        for curParam=parameterNames
            // TODO: implement support for multiple arrays
            controllerParameter = jinvoke(block, "getUsedImplementationParameter", curParam);
            parameter.isArray = jinvoke(controllerParameter, "isArray");
            parameter.isFlashArray = jinvoke(controllerParameter, "isFlashArray");
            if parameter.isArray  & parameter.isFlashArray then
                curParamType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getParameter", curParam), "getDataType"), "getName");
                mfprintf(fileID, "\n    /* Initialization of flash parameter arrays */\n");
                mfprintf(fileID, "    if (GetNopar(block) < %i) { /* index = 0 requires number >= 1 */\n", index);
                mfprintf(fileID, "        set_block_error(BLOCK_ERROR_INPUT_OUT_OF_DOMAIN);\n");
                mfprintf(fileID, "    } else if (!((GetOparSize(block, %i, 2) >= 1) & (GetOparSize(block, %i, 1) == 1))) {\n", index, index);
                mfprintf(fileID, "        set_block_error(BLOCK_ERROR_INPUT_OUT_OF_DOMAIN);\n");
                mfprintf(fileID, "    } else if (GetOparType(block, %i) == SCSREAL_N) {\n", index);
                mfprintf(fileID, "        SCSREAL_COP *xcosblock_Opar;  \n");
                mfprintf(fileID, "        int i;\n");
                mfprintf(fileID, "        %s *ctrl_param;\n", curParamType);
                mfprintf(fileID, "        ctrl_param = (%s*)(pT%s_%s + 1);\n", curParamType, blockInfo.blockName, curImpl); // +1 has to be replaced with size of data before array data
                mfprintf(fileID, "        xcosblock_Opar = GetRealOparPtrs(block, %i);\n", index);
                mfprintf(fileID, "        for (i = GetOparSize(block, %i, 2) - 1; i >= 0; i--){\n", index);
                mfprintf(fileID, "            ctrl_param[i] = (%s)xcosblock_Opar[i];\n", curParamType);
                mfprintf(fileID, "        }\n");
                mfprintf(fileID, "        pT%s_%s->%s = ctrl_param;\n", blockInfo.blockName, curImpl, curParam);
                mfprintf(fileID, "    } else {\n");
                mfprintf(fileID, "        set_block_error(BLOCK_ERROR_INPUT_OUT_OF_DOMAIN);\n");
                mfprintf(fileID, "    }\n");
                index = index + 1;
            end
        end
        
        
        mfprintf(fileID, "    %s_%s_C__set_parameter(block, pT%s_%s);\n", blockInfo.xcosName, curImpl, blockInfo.blockName, curImpl);
        
        mfprintf(fileID, "\n    /* Assignment of inports */\n");
        index = 1;
        for curInport=inportNames
            curInportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getInport", curInport), "getDataType"), "getName");
            curFormat = dataTypeToQFormat(curInportType);
            mfprintf(fileID, "    inport_%s_p = GetInPortPtrs(block, %i);\n", curInport, index);
            mfprintf(fileID, "    inport_%s = convert_double_to_%s(*inport_%s_p);\n", curInport, curFormat, curInport);
            mfprintf(fileID, "    pT%s_%s->%s = &inport_%s;\n", blockInfo.blockName, curImpl, curInport, curInport);
            index = index + 1;
        end
        
        mfprintf(fileID, "\n    /* Assignment of parameter arrays */\n");
        for curParam=parameterNames
            // fetch parameter details
            // TODO: implement support for multiple arrays
            controllerParameter = jinvoke(block, "getUsedImplementationParameter", curParam);
            parameter.isArray = jinvoke(controllerParameter, "isArray");
            parameter.isFlashArray = jinvoke(controllerParameter, "isFlashArray");
            if parameter.isArray | parameter.isFlashArray then
                mfprintf(fileID, "    pT%s_%s->%s = pT%s_%s + 1;\n", blockInfo.blockName, curImpl, curParam, blockInfo.blockName, curImpl); // +1 has to be replaced with size of data before array data
            end
        end
        
        mfprintf(fileID, "\n    /* Initialization */\n");
        mfprintf(fileID, "    %s_%s_Init(pT%s_%s);\n", blockInfo.blockName, curImpl, blockInfo.blockName, curImpl);

        
        mfprintf(fileID, "\n    /* Assignment of outports */\n");
        index = 1;
        for curOutport=outportNames
            curOutportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getOutport", curOutport), "getDataType"), "getName");
            curFormat = dataTypeToQFormat(curOutportType);
            mfprintf(fileID, "    outport_%s = GetOutPortPtrs(block, %i);\n", curOutport, index);
            mfprintf(fileID, "    *outport_%s = convert_%s_to_double(pT%s_%s->%s);\n", curOutport, curFormat, blockInfo.blockName, curImpl, curOutport);
            index = index + 1;
        end
        
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");

        //----------------------------------------------------------------------
        // Ending
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__Ending(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    %s_%s *pT%s_%s;\n", convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"), blockInfo.blockName, curImpl);
        mfprintf(fileID, "    pT%s_%s = GetWorkPtrs(block);\n", blockInfo.blockName, curImpl);
        mfprintf(fileID, "    scicos_free(pT%s_%s);\n", blockInfo.blockName, curImpl);
        
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");


        //----------------------------------------------------------------------
        // State Update f
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__StateUpdate_f(scicos_block* block) {\n", blockInfo.xcosName, curImpl);

        if jinvoke(jinvoke(block, "getUsedImplementation"), "isUpdateEnabled") then
            isUpdateEnabled = %t;
        else
            isUpdateEnabled = %f;
        end

//        if blockInfo.TimeDependency then
//            mfprintf(fileID, "    %s_%s *pT%s_%s;\n", convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"), blockInfo.blockName, curImpl);
//            
//            mfprintf(fileID, "\n    /* Declaration of inports */\n");
//            for curInport=inportNames
//                curInportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getInport", curInport), "getDataType"), "getName");
//                mfprintf(fileID, "    double *inport_%s_p;\n", curInport);
//                mfprintf(fileID, "    %s inport_%s;\n", curInportType, curInport);
//            end
//            
//            mfprintf(fileID, "\n    /* Declaration of outports */\n");
//            for curOutport=outportNames
//                mfprintf(fileID, "    double *outport_%s;\n", curOutport);
//            end
//            
//            mfprintf(fileID, "\n    /* *** */\n");
//            mfprintf(fileID, "    pT%s_%s = GetWorkPtrs(block);\n", blockInfo.blockName, curImpl);
//            
//            mfprintf(fileID, "\n    /* Assignment of inports */\n");
//            index = 1;
//            for curInport=inportNames
//                curInportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getInport", curInport), "getDataType"), "getName");
//                curFormat = dataTypeToQFormat(curInportType);
//                mfprintf(fileID, "    inport_%s_p = GetInPortPtrs(block, %i);\n", curInport, index);
//                mfprintf(fileID, "    inport_%s = convert_double_to_%s(*inport_%s_p);\n", curInport, curFormat, curInport);
//                mfprintf(fileID, "    pT%s_%s->%s = &inport_%s;\n", blockInfo.blockName, curImpl, curInport, curInport);
//                index = index + 1;
//            end
//            
//            mfprintf(fileID, "\n    /* Assignment of parameter arrays */\n");
//            for curParam=parameterNames
//                // fetch parameter details
//                // TODO: implement support for multiple arrays
//                controllerParameter = jinvoke(block, "getUsedImplementationParameter", curParam);
//                parameter.isArray = jinvoke(controllerParameter, "isArray");
//                if parameter.isArray then
//                    mfprintf(fileID, "    pT%s_%s->%s = pT%s_%s + 1;\n", blockInfo.blockName, curImpl, curParam, blockInfo.blockName, curImpl);
//                end
//            end
//            
//            mfprintf(fileID, "\n    /* Update */\n");
//            if isUpdateEnabled then
//                mfprintf(fileID, "    %s_%s_Update(pT%s_%s);\n", blockInfo.blockName, curImpl, blockInfo.blockName, curImpl);
//            else
//                mfprintf(fileID, "/* Present implementation has no update function */\n");
//            end
//            
//            mfprintf(fileID, "\n    /* Assignment of outports */\n");
//            index = 1;
//            for curOutport=outportNames
//                curOutportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getOutport", curOutport), "getDataType"), "getName");
//                curFormat = dataTypeToQFormat(curOutportType);
//                mfprintf(fileID, "    outport_%s = GetOutPortPtrs(block, %i);\n", curOutport, index);
//                mfprintf(fileID, "    *outport_%s = convert_%s_to_double(pT%s_%s->%s);\n", curOutport, curFormat, blockInfo.blockName, curImpl, curOutport);
//                index = index + 1;
//            end
//        else
            mfprintf(fileID, "/* Do nothing, calling of update function and writing to outputs is done in OutputUpdate */\n");
//        end
        
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        

        //----------------------------------------------------------------------
        // State Update
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__StateUpdate(scicos_block* block) {\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    if (GetNevIn(block) > 0) {\n");
        mfprintf(fileID, "        /*\n");
        mfprintf(fileID, "        * GetNevIn(block) returns -1 in case this function was called due to an internal zero-crossing.\n");
        mfprintf(fileID, "        * GetNevIn(block)  ... activation index\n");
        mfprintf(fileID, "        */\n");
        mfprintf(fileID, "        %s_%s_C__StateUpdate_f(block);\n", blockInfo.xcosName, curImpl);
        mfprintf(fileID, "    }\n");

        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        

        //----------------------------------------------------------------------
        // Output Update
        //----------------------------------------------------------------------
        mfprintf(fileID, "static void %s_%s_C__OutputUpdate(scicos_block* block) {\n", blockInfo.xcosName, curImpl);

//        if (~blockInfo.TimeDependency) then
            mfprintf(fileID, "    %s_%s *pT%s_%s;\n", convstr(blockInfo.blockName, "u"), convstr(curImpl, "u"), blockInfo.blockName, curImpl);
            
            mfprintf(fileID, "\n    /* Declaration of inports */\n");
            for curInport=inportNames
                curInportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getInport", curInport), "getDataType"), "getName");
                mfprintf(fileID, "    double *inport_%s_p;\n", curInport);
                mfprintf(fileID, "    %s inport_%s;\n", curInportType, curInport);
            end
            
            
            mfprintf(fileID, "\n    /* Declaration of outports */\n");
            for curOutport=outportNames
                mfprintf(fileID, "    double *outport_%s;\n", curOutport);
            end
            
            mfprintf(fileID, "\n    /* *** */\n");
            mfprintf(fileID, "    pT%s_%s = GetWorkPtrs(block);\n", blockInfo.blockName, curImpl);
            
            mfprintf(fileID, "\n    /* Assignment of inports */\n");
            index = 1;
            for curInport=inportNames
                curInportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getInport", curInport), "getDataType"), "getName");
                curFormat = dataTypeToQFormat(curInportType);
                mfprintf(fileID, "    inport_%s_p = GetInPortPtrs(block, %i);\n", curInport, index);
                mfprintf(fileID, "    inport_%s = convert_double_to_%s(*inport_%s_p);\n", curInport, curFormat, curInport);
                mfprintf(fileID, "    pT%s_%s->%s = &inport_%s;\n", blockInfo.blockName, curImpl, curInport, curInport);
                index = index + 1;
            end
            
            mfprintf(fileID, "\n    /* Assignment of parameter arrays */\n");
            for curParam=parameterNames
                // fetch parameter details
                // TODO: implement support for multiple arrays
                controllerParameter = jinvoke(block, "getUsedImplementationParameter", curParam);
                parameter.isArray = jinvoke(controllerParameter, "isArray");
                parameter.isFlashArray = jinvoke(controllerParameter, "isFlashArray");
                if parameter.isArray | parameter.isFlashArray then
                    mfprintf(fileID, "    pT%s_%s->%s = pT%s_%s + 1;\n", blockInfo.blockName, curImpl, curParam, blockInfo.blockName, curImpl); // +1 has to be replaced with size of data before array data
                end
            end
            
            mfprintf(fileID, "\n    /* Update */\n");
            if isUpdateEnabled then
                mfprintf(fileID, "    %s_%s_Update(pT%s_%s);\n", blockInfo.blockName, curImpl, blockInfo.blockName, curImpl);
            else
                mfprintf(fileID, "/* Present implementation has no update function */\n");
            end
            
            mfprintf(fileID, "\n    /* Assignment of outports */\n");
            index = 1;
            for curOutport=outportNames
                curOutportType = jinvoke(jinvoke(jinvoke(jinvoke(block, "getUsedImplementation"), "getOutport", curOutport), "getDataType"), "getName");
                curFormat = dataTypeToQFormat(curOutportType);
                mfprintf(fileID, "    outport_%s = GetOutPortPtrs(block, %i);\n", curOutport, index);
                mfprintf(fileID, "    *outport_%s = convert_%s_to_double(pT%s_%s->%s);\n", curOutport, curFormat, blockInfo.blockName, curImpl, curOutport);
                index = index + 1;
            end
//        else
//            mfprintf(fileID, "/* Do nothing, calling of update function and writing to outputs is done in StateUpdate */\n");
//        end
        
        mfprintf(fileID, "}\n");
        mfprintf(fileID, "\n\n");
        
        // close file
        mclose(fileID);
        mprintf("Computational function %s successfully written.\n", fileName);
    end
    
catch
    // some error creating the file occured
    mclose(fileID); // try to close the file
    disp("Error creating C-code files for block " + blockInfo.blockName + ": " + lasterror());
end

endfunction

// Converts enum data type string to corresponding Q-format string
// Parameters:
// dataType - enum data type
// QFormat - corresponding Q-format string
function [QFormat] = dataTypeToQFormat(dataType)
    
select dataType
    case "int8" then
        QFormat = "Q7";
    case "uint8" then
        QFormat = "Q7";
    case "int16" then
        QFormat = "Q15";
    case "uint16" then
        QFormat = "Q15";
    case "int32" then
        QFormat = "Q31";
    case "uint32" then
        QFormat = "Q31";
    case "int64" then
        QFormat = "Q63";
    case "uint64" then
        QFormat = "Q63";
    case "float32" then
        QFormat = "float32";
    case "float64" then
        QFormat = "float64";
    else
        QFormat = dataType;
end
    
endfunction
